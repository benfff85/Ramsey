import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.StringTokenizer;
import javax.swing.JFileChooser;

public class Ramsey {
	
	/*
	 * Two Global Variables we will be concerned with:
	 * numOfElements = 288
	 * cliqueSize = 8
	 * but values are flexible
	 */
	int numOfElements = 14;
	int cliqueSize = 4;
	
	public void main(){
		int[][] cayleyTable = openCayleyTable();
		int coloring[] = new int[numOfElements];
		for(int i=0;i<numOfElements/2;i++){
			coloring[i]=1;
		}
		int[][] cayleyGraph;
		boolean result;
		while(coloring[0]!=-1){
			cayleyGraph = generateCayleyGraph(cayleyTable, coloring);
			result = cliqueChecker(cayleyGraph,cliqueSize,1);
			if(result==false){
				result = cliqueChecker(cayleyGraph,cliqueSize,0);
				if(result==false){
					System.out.println("This does NOT contain a complete subgraph of order 8");
					printCayleyGraph(cayleyGraph);
				}
			}
			coloring=getNextColoring(coloring);
		}
	}
	
	/*
	 * Will create a 2D array signifying the cayley table of a group given the input file which is generated by GAP and later conditioned. 
	 * I have sample input file if needed.
	 */
	public int[][] openCayleyTable(){
		String inputLine;
		StringTokenizer st;
		int x,y;
		int[][] array = new int[numOfElements][numOfElements];
		try{
			JFileChooser chooser = new JFileChooser();	
			int retval = chooser.showOpenDialog(null);
			if (retval == JFileChooser.APPROVE_OPTION) {
				File file = chooser.getSelectedFile();
				BufferedReader buffRead = new BufferedReader(new FileReader(file));
				y=0;
				while((inputLine = buffRead.readLine())!=null){
					st=new StringTokenizer(inputLine);
					x=0;
					while(st.hasMoreTokens()) {
						//-1 because will be in terms of 1:n where n is the number of elements but will be easier to understand in array if elements are 0:(n-1)
				        array[y][x]=(Integer.parseInt(st.nextToken()))-1;
				        x++;
					}
					y++;
				}
			}
		}
		catch (IOException e) {
			System.out.println("IO Error, returning null");
		}
		return array;
	}
	/////BEAN: I NEED TO MAKE A SMALL CHANGE TO THIS METHOD, DO THIS LAST PLEASE//////
	/*
	 * Generates Cayley graph given cayley table of the group and the coloring configuration
	 * Cayley graph will be expressed as an numOfElements*numOfElements adjecency matrix
	 * The values in the matrix are as follows:
	 *  0: no color for given edge
	 *  1: color for given edge
	 */
	public int[][] generateCayleyGraph(int[][] cayleyTable, int[] coloring){
		int cayleyGraph[][] = new int[numOfElements][numOfElements];
		
		for(int colorIndex=0; colorIndex<numOfElements; colorIndex++){
			if(coloring[colorIndex]==1){
				for(int vertexIndex=0; vertexIndex<numOfElements; vertexIndex++){
					cayleyGraph[vertexIndex][cayleyTable[vertexIndex][colorIndex]]=1;
					cayleyGraph[cayleyTable[vertexIndex][colorIndex]][vertexIndex]=1;
				}
			}
		}
		return cayleyGraph;
	}
	
	/*
	 * This will analyze the cayley graph and see if it is a example of a graph of order numOfElements that does have a complete subgraph of order k (cliqueSize)
	 * in this case k will be equal to 8 for R(8,8)
	 * If it has a complete subgraph it will return true, else it will return false
	 */
	public boolean cliqueChecker(int[][] cayleyGraph, int cliqueSize, int lookingFor){
		
		int tree[][] = new int[cliqueSize][numOfElements];				
		int pointerArray[] = new int[cliqueSize];					
		int pointerArrayIndex=0;
		int link;

		//Fill first level of tree with all verticies
		for(int vertex=0; vertex<numOfElements; vertex++){
		      tree[pointerArrayIndex][vertex]=vertex;
		}
		
		//Main Algorithm
		while(pointerArray[0]<=((numOfElements-cliqueSize)+1)){
		    link=tree[pointerArrayIndex][pointerArray[pointerArrayIndex]];
		    pointerArray[pointerArrayIndex]++;
		    pointerArrayIndex++;

		    for(int i=0; i<numOfElements; i++){
		        if(cayleyGraph[link][i]==lookingFor && i>link && prevLevelContains(i,tree[pointerArrayIndex-1])){
			        tree[pointerArrayIndex][pointerArray[pointerArrayIndex]]=i;	
			        pointerArray[pointerArrayIndex]++;
			    }	    
		    }
		    
		   		    
		    //If at least (cliqueSize-Level) elements, then successful row, reset pointer for row and move to next level
		    if(pointerArray[pointerArrayIndex]>=(cliqueSize-pointerArrayIndex)){
		    	pointerArray[pointerArrayIndex]=0;
		    	if(pointerArrayIndex==(cliqueSize-1)){
		    		return true;
		        }
		    }
		    //Otherwise there are not enough elements for a clique, delete row and slide pointer for previous level up one repeat until link-to-be is nonzero
		    else{
		    	//printTree(tree);
		    	for(int i=0; i<numOfElements && tree[pointerArrayIndex][i]!=0; i++){
		        	tree[pointerArrayIndex][i]=0;
		        }
		        pointerArray[pointerArrayIndex]=0;	
		        pointerArrayIndex--;
		        
		        while(tree[pointerArrayIndex][pointerArray[pointerArrayIndex]]==0){
		        	for(int i=0; i<numOfElements && tree[pointerArrayIndex][i]!=0; i++){
			        	tree[pointerArrayIndex][i]=0;
			        }
			        pointerArray[pointerArrayIndex]=0;	
			        pointerArrayIndex--;
		        }
		    }
		}
		return false;
	}
	
	/*
	 * This will determine if the previous level of the tree also contained the element in question
	 */
	public boolean prevLevelContains(int element, int[] level){
		for(int i=0;i<numOfElements && level[i]<=element;i++){
			if(level[i]==element){
				return true;
			}
		}
		return false;
	}
	
	/*
	 * Will output the cayley graph counterexample in a format compatible with mathematica
	 */
	public void printCayleyGraph(int[][] cayleyGraph){
		String output = "";
		output += "GraphPlot[{";
		for(int i=0;i<numOfElements;i++){
			output += "{";
			for(int j=0;j<numOfElements;j++){
			    output += cayleyGraph[i][j] + ", ";
			}
			output = output.substring(0,output.length()-2);
			output += "},";
		}
		output = output.substring(0,output.length()-1);
		output += "}, Method -> CircularEmbedding]";
		System.out.println(output);
	}
	
	/*
	 * Finds the next coloring, Runs through all combinations, will return -1 in the first position 
	 * if all colorings have been generated
	 */
	 public int[] getNextColoring(int[] coloring){
		int i=0;
		while(i<numOfElements-1){
			if(coloring[i]==1 && coloring[i+1]==0){
				//Slide the least significant 1 to the right where at first possibility
				coloring[i+1]=1;
				coloring[i]=0;
				
				//Count how many ones are to the left of index i
				int countOnes=0;
				for(int j=0;j<i;j++){ 
					if(coloring[j]==1){
						countOnes++;
					}
				}
				
				//slide all of these ones all the way to the left
				for(int j=0;j<i;j++){
					if(j<countOnes){
						coloring[j]=1;
					}
					else{
						coloring[j]=0;
					}
				}
				return coloring;
			}
			//Otherwise increase i to look for next least significant one with possibility of movement.
			i++;
		}
		//If we reached this point we have exausted all possible colorings.
		coloring[0]=-1;
		return coloring;
	}
}
