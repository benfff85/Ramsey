import java.io.*;
import java.util.*;
import javax.swing.JFileChooser;

public class test {
	
	int numOfElements = 288;
	int cliqueSize = 8;
	Q q;

	public void main(Q q){		
		this.q = q;
		continuousSearch();
	}
	
	/*public void main2(){
		int[][] cayleyTable = openCayleyTable();
		int coloring[] = new int[numOfElements];
		for(int i=0;i<numOfElements/2;i++){
			coloring[i]=1;
		}
		int[][] cayleyGraph;
		boolean result;
		
		for(int coloringCount=0; coloringCount<1; coloringCount++){
			cayleyGraph = generateCayleyGraph(cayleyTable, coloring);
			result = cliqueChecker(cayleyGraph,cliqueSize,1);
			if(result==false){
				result = cliqueChecker(cayleyGraph,cliqueSize,0);
				if(result==false){
		    		System.out.println("This does NOT contain a complete subgraph of order " + cliqueSize + "!!");
					printCayleyGraph(cayleyGraph);
				}
			}
		}
	}*/
	
	
	public void continuousSearch(){

		CayleyGraphOld cayleyGraph;
		boolean notFound=true;
		
		cayleyGraph = new CayleyGraphOld(this.numOfElements, this.cliqueSize);
		//cayleyGraph.calculateDistribution();
		while(notFound){
		    q.increment();
		    q.maxFirstTreeTracker(cayleyGraph.clique[0]);
		    if(cayleyGraph.cliqueChecker(1)){
		    	printNegativeCase(cayleyGraph);
		    } else {
		    	if(cayleyGraph.cliqueChecker(0)){
		    		q.maxFirstTreeTracker(cayleyGraph.clique[0]);
			    	printNegativeCase(cayleyGraph);
		    	} else {
		    		System.out.println("This does NOT contain a complete subgraph of order " + cliqueSize + "!!");
		    		cayleyGraph.printCayleyGraph();
		    		System.out.println("Count: " + q.count);
		    		notFound=false;
		    	}
		    }
		    
		    
		//cayleyGraph.generateRandomGraph();
		//cayleyGraph.mutateGraphRandom(1);
		cayleyGraph.mutateGraphTargeted();
		cayleyGraph.calculateDistribution();
		//cayleyGraph.mutateGraphTargetedDistribution();
		
		if (q.getCount()%1000==0){
			printInterval(cayleyGraph);
		}
		}
	}
	
	public void printNegativeCase(CayleyGraphOld cayleyGraph){
    	//System.out.println("This does contain a complete subgraph of order " + cliqueSize);
    	//cayleyGraph.printCayleyGraph();
    	//cayleyGraph.printClique();
		//cayleyGraph.printDistribution();
		//cayleyGraph.printDistributionSummary();
		//cayleyGraph.printZeroOneCount();
		//System.out.println("Count: " + q.count);
		System.out.println("Max First Tree Element: " + q.maxFirstTree);
	}
	
	public void printInterval(CayleyGraphOld cayleyGraph){
    	System.out.println("###############################################################");
		//System.out.println("This does contain a complete subgraph of order " + cliqueSize);
    	//cayleyGraph.printCayleyGraph();
    	//cayleyGraph.printClique();
		//cayleyGraph.printDistribution();
		cayleyGraph.printDistributionSummary();
		//cayleyGraph.printZeroOneCount();
		System.out.println("Count: " + q.count);
		//System.out.println("Max First Tree Element: " + q.maxFirstTree);
	}
		
	
	
	

	/*
	 * Will create a 2D array signifying the cayley table of a group given the input file which is generated by GAP and later conditioned. 
	 * I have sample input file if needed.
	 */
	public int[][] openCayleyTable(){
		String inputLine;
		StringTokenizer st;
		int x,y;
		int[][] array = new int[numOfElements][numOfElements];
		try{
			JFileChooser chooser = new JFileChooser();	
			int retval = chooser.showOpenDialog(null);
			if (retval == JFileChooser.APPROVE_OPTION) {
				File file = chooser.getSelectedFile();
				BufferedReader buffRead = new BufferedReader(new FileReader(file));
				y=0;
				while((inputLine = buffRead.readLine())!=null){
					st=new StringTokenizer(inputLine);
					x=0;
					while(st.hasMoreTokens()) {
						//-1 because will be in terms of 1:n where n is the number of elements but will be easier to understand in array if elements are 0:(n-1)
				        array[y][x]=(Integer.parseInt(st.nextToken()))-1;
				        x++;
					}
					y++;
				}
				buffRead.close();
			}
		}
		catch (IOException e) {
			System.out.println("IO Error, returning null");
		}
		return array;
	}
	

	/*
	 * Finds the next coloring, currently just counting up in binary, need to modify to generate only colorings where there are half 1's and half 0's 
	 * Also need to optimize to find elements and their inverses and assign the same color?
	 */
	public int[] getNextColoring(int[] coloring){
		int i=0;
		while(coloring[i]==1){
			coloring[i]=0;
			i++;
		}
		coloring[i]=1;
		return coloring;
	}
	

	
}